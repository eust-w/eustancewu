---
layout: post
tags: 基础
---



[toc]

go逃逸分析

1. 如果函数外部没有引用，则优先放到栈中；
2. 如果函数外部存在引用，则必定放到堆中；

指针逃逸

函数返回局部变量的指针导致指针逃逸

```go
package main
func pointerEscapeFunc() *int{
    var v int
    return &v
}

func main(){
    pointerEscapeFunc()//v会被分配到堆上
    return
}
```

```shell
host$ go build -gcflags '-m -l' tem.go #-m打印信息，-l忽略inline信息
# command-line-arguments
./tem.go:3:6: moved to heap: v #可见v被分配到了堆上
```

栈空间不足

go的goroutine初始栈大小为2KB，go可以增大栈大小，但不可超过系统栈限制(使用`ulimit -s`查看)，超过一定大小的变量将会逃逸到堆上，不同go版本大小限制不同

```go
package main
func stackSpaceExhausted(){
    v := make([]int,0,10000)
}

func main(){
    stackSpaceExhausted()
}
```

```shell
host$ go build -gcflags '-m -l' tem.go 
# command-line-arguments
./tem.go:3:11: make([]int, 20000, 40000) escapes to heap # 可见逃逸到了堆上
```



